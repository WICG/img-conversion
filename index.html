<!DOCTYPE html>
<html>
  <head>
    <title>
      ImageData conversion extensions
    </title>
    <meta charset='utf-8'>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' async=""
    class='remove'>
</script>
    <script class='remove'>
var respecConfig = {
    specStatus: "webspec",
    shortName: "img-conversion",
    noLegacyStyle: true,
    edDraftURI: "http://wicg.github.io/img-conversion/",
    editors: [{
    name: "Ashley Gullen",
    url: "https://twitter.com/AshleyGullen",
    mailto: "ashley@scirra.com",
    company: "Scirra Ltd",
    companyURL: "https://www.scirra.com"
    }, {
    name: "Yoav Weiss"
    }],
    repository: "WICG/img-conversion",
    //publishDate: "2015-07-07",
    //previousMaturity: "FPWD",
    //previousPublishDate:  "1977-03-15",
    wg: "Web Platform Incubator Community Group",
    wgURI: "https://www.w3.org/community/wicg/",
    wgPublicList: "public-wicg",
    //wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/424242/status",
    };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        This specification proposes additional <a>ImageData</a> methods that
        asynchronously convert between <a>HTMLImageElement</a>,
        <a>ImageData</a> and <a>Blob</a>.
      </p>
      <p>
        Implementors need to be aware that this specification is not stable.
        <strong>Implementors who are not taking part in the discussions will
        find the specification changing out from under them in incompatible
        ways.</strong> Vendors interested in implementing this specification
        before it eventually moves to a W3C working group should <a href=
        "https://github.com/WICG/img-conversion/">subscribe to the repository
        on GitHub</a> and take part in the discussions.
      </p>
    </section>
    <section id='sotd'></section>
    <section class="informative">
      <h2>
        Introduction
      </h2>
      <p>
        Modern web apps need asynchronous functions to process image data
        without "janking" the browser UI. The <a>ImageData</a> interface was
        originally specified for use with the canvas [[2dcontext]], and as such
        all conversions involving it generally require synchronous use of an
        intermediate <code>CanvasRenderingContext2D</code>, which may introduce
        intermediate copies and additional memory overhead. Web application
        might also need to convert images to and from Blobs representing images
        in their compressed form (such as a [[!PNG]] file). This proposal adds
        new methods to circumvent synchronous use of the canvas and avoid any
        intermediate copies of images for these use cases, as well as methods
        to test which image formats can be encoded and decoded.
      </p>
    </section>
    <section>
      <h2>
        Examples of usage
      </h2>
      <p>
        This demonstrates decompressing a <code>Blob</code> to
        <code>ImageData</code>.
      </p>
      <pre class='example highlight'>
ImageData.create(blob).then(
  imgData =&gt; doSomethingWith(imgData)
);
</pre>
      <p>
        This example demonstrates compressing an <code>ImageData</code> to a
        <code>Blob</code>, and then displaying it in a
        <code>HTMLImageElement</code>.
      </p>
      <pre class='example highlight'>
var type = (Image.canEncodeType("image/jpg")) ? "image/jpg" : "image/png";
imageData.toBlob(type).then((blob) =&gt; {
  const img = new Image();
  img.src = URL.createObjectURL(blob);
  document.body.appendChild(img);
});
</pre>
    </section>
    <section>
      <h2>
        Extensions to the <code>ImageData</code> class
      </h2>
      <pre class="idl">
typedef (HTMLImageElement or Blob) ImageSource;

partial interface ImageData {
  [NewObject] Promise&lt;Blob&gt; toBlob (optional DOMString type, optional EncoderOpts options);
  [NewObject] static Promise&lt;ImageData&gt; create (ImageSource source);
  static CanPlayTypeResult canDecodeType (DOMString mimeType);
  static CanPlayTypeResult canEncodeType (DOMString mimeType);
};

dictionary EncoderOpts {
  Operation operation;
  DOMString type = "image/png";
};
</pre>
      <section>
        <h3>
          <code>toBlob()</code> method
        </h3>
        <p>
          The <dfn><code>toBlob</code></dfn> method, is called, run the
          <dfn>steps to convert image data to a blob</dfn>:
        </p>
        <ol>
          <li>...steps...
          </li>
        </ol>
      </section>
      <section>
        <h3>
          static <code>create()</code> method
        </h3>
        <p>
          The <dfn>create()</dfn>
        </p>
      </section>
      <section>
        <h3>
          static <code>canDecodeType()</code> method
        </h3>
        <p>
          To check if the user agent <dfn>can decode an image type</dfn>, run
          the steps below.
        </p>
        <ol>
          <li>...
          </li>
        </ol>
      </section>
      <section>
        <h3>
          static <code>canEncodeType()</code> method
        </h3>
        <p>
          To check if the user agent <dfn>can encode an image type</dfn>, run
          the steps below.
        </p>
        <ol>
          <li>...
          </li>
        </ol>
      </section>
      <section>
        <h3>
          Checking supported operations
        </h3>
        <p>
          To <dfn>check if <var>operation</var> is supported</dfn> using an
          <var>operation</var>, optionally a <var>type</var>, run these steps:
        </p>
        <ol>
          <li>If type is an empty string, or an invalid MIME type, return the
          empty string.
          </li>
          <li>If <var>type</var> is a MIME type that the user agent knows it
          cannot perform <var>operation</var> on, or the type
          "application/octet-stream", then return the empty string.
          </li>
          <li>If the user agent is confident that the <var>type</var>
          represents an MIME type that it can perform <var>operation</var> on,
          return "probably".
          </li>
          <li>Otherwise, return "maybe".
          </li>
        </ol>
      </section>
    </section>
    <section class="informative appendix">
      <h2>
        Limitations
      </h2>
      <p>
        Conversion from an <code>ImageBitmap</code> is omitted to avoid
        complications with implementations that store images on the GPU in
        premultiplied form. Therefore converting an <code>ImageBitmap</code> to
        an <code>ImageData</code> could require an expensive readback from the
        GPU, and make it difficult to avoid a lossy pass through a
        premultiplied format. Instead whatever the <code>ImageBitmap</code> was
        created from should be directly converted to an <code>ImageData</code>
        without using <code>ImageBitmap</code> as an intermediate stage.
      </p>
      <p>
        This API does not cover animated formats, in particular GIF, APNG or
        MJPEG. It is suggested that ImageData remains as a representation of a
        single static image, and another interface providing access to an array
        of ImageData be specified for animated formats with its own methods to
        convert to/from Blob. If an animated format is specified for ImageData,
        it should operate on the first frame only.
      </p>
    </section>
  </body>
</html>
